```.
├── package.json                  # 项目配置与依赖, 已经完成。
├── index.js                      # 主入口文件, 已经完成。
├── config.json                   # 配置文件示例, 已经完成。
├── .env                          # 环境变量示例文件, 已经完成。
├── README.md                     # 项目说明文档, 已经完成。
├── src
│   ├── cli.js                    # 命令行处理模块, 已经完成。
│   ├── config.js                 # 配置读取与解析模块, 已经完成。
│   ├── scheduler.js              # 调度模块, 已经完成。
│   ├── controller.js             # 主流程控制器, 已经完成。
│   ├── modules
│   │   ├── git.js                # Git 操作模块, 已经完成。
│   │   ├── conflict-resolver.js  # 冲突解决模块
│   │   ├── code-reviewer.js      # 代码审查模块
│   │   ├── tester.js             # 测试运行模块
│   │   ├── logger.js             # 日志记录模块, 已经完成。
│   │   └── mailer.js             # 邮件通知模块
│   └── utils
│       ├── github-api.js         # GitHub API 调用工具
│       ├── llm-client.js         # LLM 客户端
│       └── helpers.js            # 通用辅助函数
└── logs                          # 日志输出目录
```

# 使用流程

1. **初始化配置**：用户编写配置文件（如 `config.json`），指定账户、仓库和参数。确保每个账户的 `token` 已设置环境变量或写入配置（注意安全）。
2. **运行工具**：通过命令行执行主脚本，例如 `node index.js --config config.json`。工具读取配置，并开始对每个账户和仓库执行同步任务。若启用了定时模式，则注册定时任务定期执行。
3. **仓库克隆和更新**：对于每个 Fork 仓库，工具检查本地目录：

   * 如果本地不存在，则使用 simple-git 自动克隆仓库至指定工作路径。
   * 添加上游远程（若尚未配置）并拉取最新代码。
4. **检测并合并上游更新**：对比本地开发分支与上游分支的新提交：

   * 如果上游无新提交，跳过该仓库（可记录“已最新”）。
   * 如果有新提交，切换到开发分支并执行合并。

     * **合并成功**：生成合并提交并推送至 Fork。
     * **出现冲突**：触发冲突解决模块，收集上下文并调用 LLM 生成合并结果。应用 LLM 输出并提交后推送。如果自动合并失败（如 LLM 建议不正确），可配置回滚到合并前状态。
5. **日志输出**：记录每一步操作信息，包括哪些仓库更新、是否发生冲突、LLM 结果摘要等。日志可输出到控制台并写入文件。
6. **邮件通知**：任务完成后，工具汇总日志内容并通过 SMTP 发送邮件给配置的收件人。邮件中包含更新结果或附件形式的详细日志，以便开发团队查阅。

整个流程中，**安全**和**备份**是重要考量。例如在合并前记录目标分支的当前提交 ID，以便在需要时用 `git reset --hard <commit-id>` 恢复。此外，在并发运行时建议对不同仓库分开工作目录，避免相互干扰。


当执行 `git merge` 时若发生冲突，冲突解决模块需完成以下设计：
* **收集冲突上下文**：识别冲突文件（simple-git 的 `.merge()` 出错时通常可获取冲突列表）。对于每个冲突文件，获取共同基线（base）、上游更改（theirs）和本地更改（ours）。可以使用 `git diff --base` 或读取冲突文件中的 `<<<<<<` 标记区块来拆分这三部分。
* **构建提示词**：将提取的上下文组织成适合 LLM 的输入格式。参考研究，Gmerge 工具会将上下游与冲突相关的源代码变更提取并转换为中间表示，然后构造 GPT-3 的输入。我们可以采用类似方式。例如，将文件名、合并目标分支和冲突描述加入 prompt，提示 LLM “请将上游更改合并到本地代码中，保留本地功能”。提示词可以包含示例（one/few-shot）来指导模型如何合并冲突。
* **调用 LLM 接口**：使用 OpenAI SDK（或 HTTP 请求）调用聊天或补全接口，传入构建好的 prompt 并获取模型输出。应限制 token 数量，必要时分文件或函数级别调用以降低复杂度。
* **应用合并结果**：将 LLM 返回的合并代码覆盖原冲突文件内容，执行 `git add <file>` 并提交。提交信息可注明“自动合并（LLM 辅助）”。
* **安全回滚**：为了防止自动合并错误导致代码损坏，建议在尝试合并前记录原始提交 ID。如 LLM 结果不合预期，可通过 `git reset --hard <原始提交>` 回滚。
* **测试与验证**（可选）：合并后可触发自动化测试脚本，验证功能未中断。如集成测试失败，则将结果包含在日志或邮件报告中。这样可在问题发生时提前通知开发者。